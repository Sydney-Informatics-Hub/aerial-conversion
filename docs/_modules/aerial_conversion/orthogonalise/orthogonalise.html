<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>aerial_conversion.orthogonalise.orthogonalise &mdash; Aerial Conversion v1.2.0 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../_static/documentation_options.js?v=95484ca5"></script>
        <script src="../../../_static/doctools.js?v=888ff710"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            Aerial Conversion
          </a>
              <div class="version">
                v1.2.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"></div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Aerial Conversion</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">aerial_conversion.orthogonalise.orthogonalise</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for aerial_conversion.orthogonalise.orthogonalise</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    File name: orthogonalize_polygon.py</span>
<span class="sd">    Author: Martin Machyna</span>
<span class="sd">    Email: machyna@gmail.com</span>
<span class="sd">    Date created: 9/28/2020</span>
<span class="sd">    Date last modified: 9/30/2020</span>
<span class="sd">    Version: 1.0.4</span>
<span class="sd">    License: GPLv3</span>
<span class="sd">    credits: Jérôme Renard [calculate_initial_compass_bearing(): https://gist.github.com/jeromer/2005586]</span>
<span class="sd">             JOSM project  [general idea: https://github.com/openstreetmap/josm/blob/6890fb0715ab22734b72be86537e33d5c4021c5d/src/org/openstreetmap/josm/actions/OrthogonalizeAction.java#L334]</span>
<span class="sd">    Python Version: Python 3.8.5</span>
<span class="sd">    Modules: geopandas==0.8.2</span>
<span class="sd">             pandas==1.2.1</span>
<span class="sd">             Shapely==1.7.1</span>
<span class="sd">             Fiona==1.8.18</span>
<span class="sd">             numpy==1.19.5</span>
<span class="sd">             pyproj==3.0.0.post1</span>
<span class="sd">    Changelog: 1.0.1 - Added constraint that in order to make the next segment continue in the same direction as the previous segment, it can not deviate from that direction more than +/- 20 degrees.</span>
<span class="sd">               1.0.2 - Fix cases when building is at ~45˚ angle to cardinal directions</span>
<span class="sd">                     - Added improvement when 180˚ turns are present the builing shape</span>
<span class="sd">               1.0.3 - Leave sides of polygon that are meant to be skewed untouched</span>
<span class="sd">               1.0.4 - Add orthogonalization for inner polygon rings (holes)</span>
<span class="sd">               1.0.5 - Fix bug when polygon is not valid  --- By Sahand Vahidnia (@sahandv) 23-11-2023</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">statistics</span>

<span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="kn">from</span> <span class="nn">shapely</span> <span class="kn">import</span> <span class="n">speedups</span>
<span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">Polygon</span>
<span class="kn">from</span> <span class="nn">shapely.validation</span> <span class="kn">import</span> <span class="n">explain_validity</span><span class="p">,</span> <span class="n">make_valid</span>

<span class="n">speedups</span><span class="o">.</span><span class="n">enable</span><span class="p">()</span>


<div class="viewcode-block" id="calculate_initial_compass_bearing">
<a class="viewcode-back" href="../../../aerial_conversion.orthogonalise.html#aerial_conversion.orthogonalise.orthogonalise.calculate_initial_compass_bearing">[docs]</a>
<span class="k">def</span> <span class="nf">calculate_initial_compass_bearing</span><span class="p">(</span><span class="n">pointA</span><span class="p">,</span> <span class="n">pointB</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculates the bearing between two points.</span>

<span class="sd">    The formulae used is the following:</span>
<span class="sd">        θ = atan2(sin(Δlong).cos(lat2),</span>
<span class="sd">                  cos(lat1).sin(lat2) − sin(lat1).cos(lat2).cos(Δlong))</span>

<span class="sd">    :Parameters:</span>
<span class="sd">      - `pointA: The tuple representing the latitude/longitude for the</span>
<span class="sd">        first point. Latitude and longitude must be in decimal degrees</span>
<span class="sd">      - `pointB: The tuple representing the latitude/longitude for the</span>
<span class="sd">        second point. Latitude and longitude must be in decimal degrees</span>

<span class="sd">    :Returns:</span>
<span class="sd">      The bearing in degrees</span>

<span class="sd">    :Returns Type:</span>
<span class="sd">      float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">pointA</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">pointB</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Only tuples are supported as arguments&quot;</span><span class="p">)</span>

    <span class="n">lat1</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">pointA</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">lat2</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">pointB</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="n">diffLong</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">pointB</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pointA</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">diffLong</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat2</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat1</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lat2</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span>
        <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lat1</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat2</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">diffLong</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="n">initial_bearing</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

    <span class="c1"># Now we have the initial bearing but math.atan2 return values</span>
    <span class="c1"># from -180° to + 180° which is not what we want for a compass bearing</span>
    <span class="c1"># The solution is to normalize the initial bearing as shown below</span>
    <span class="n">initial_bearing</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">initial_bearing</span><span class="p">)</span>
    <span class="n">compass_bearing</span> <span class="o">=</span> <span class="p">(</span><span class="n">initial_bearing</span> <span class="o">+</span> <span class="mi">360</span><span class="p">)</span> <span class="o">%</span> <span class="mi">360</span>

    <span class="k">return</span> <span class="n">compass_bearing</span></div>



<div class="viewcode-block" id="calculate_segment_angles">
<a class="viewcode-back" href="../../../aerial_conversion.orthogonalise.html#aerial_conversion.orthogonalise.orthogonalise.calculate_segment_angles">[docs]</a>
<span class="k">def</span> <span class="nf">calculate_segment_angles</span><span class="p">(</span><span class="n">polySimple</span><span class="p">,</span> <span class="n">maxAngleChange</span><span class="o">=</span><span class="mi">45</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculates angles of all polygon segments to cardinal directions.</span>

<span class="sd">    :Parameters:</span>
<span class="sd">      - `polySimple: shapely polygon object containing simplified building.</span>
<span class="sd">      - `maxAngleChange: angle (0,45&gt; degrees. Sets the maximum angle deviation</span>
<span class="sd">                         from the cardinal direction for the segment to be still</span>
<span class="sd">                         considered to continue in the same direction as the</span>
<span class="sd">                         previous segment.</span>

<span class="sd">    :Returns:</span>
<span class="sd">      - orgAngle: Segments bearing</span>
<span class="sd">      - corAngle: Segments angles to closest cardinal direction</span>
<span class="sd">      - dirAngle: Segments direction [N, E, S, W] as [0, 1, 2, 3]</span>

<span class="sd">    :Returns Type:</span>
<span class="sd">      list</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Convert limit angle to angle for subtraction</span>
    <span class="n">maxAngleChange</span> <span class="o">=</span> <span class="mi">45</span> <span class="o">-</span> <span class="n">maxAngleChange</span>

    <span class="c1"># Get points Lat/Lon</span>
    <span class="n">simpleX</span> <span class="o">=</span> <span class="n">polySimple</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">simpleY</span> <span class="o">=</span> <span class="n">polySimple</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Calculate angle to cardinal directions for each segment of polygon</span>
    <span class="n">orgAngle</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Original angles</span>
    <span class="n">corAngle</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Correction angles used for rotation</span>
    <span class="n">dirAngle</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># 0,1,2,3 = N,E,S,W</span>
    <span class="n">limit</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">simpleX</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)):</span>
        <span class="n">point1</span> <span class="o">=</span> <span class="p">(</span><span class="n">simpleY</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">simpleX</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">point2</span> <span class="o">=</span> <span class="p">(</span><span class="n">simpleY</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">simpleX</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="n">calculate_initial_compass_bearing</span><span class="p">(</span><span class="n">point1</span><span class="p">,</span> <span class="n">point2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">angle</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">45</span> <span class="o">+</span> <span class="n">limit</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> <span class="n">angle</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="mi">135</span> <span class="o">-</span> <span class="n">limit</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">orgAngle</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
            <span class="n">corAngle</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">angle</span> <span class="o">-</span> <span class="mi">90</span><span class="p">)</span>
            <span class="n">dirAngle</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">angle</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">135</span> <span class="o">+</span> <span class="n">limit</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="ow">and</span> <span class="n">angle</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="mi">225</span> <span class="o">-</span> <span class="n">limit</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
            <span class="n">orgAngle</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
            <span class="n">corAngle</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">angle</span> <span class="o">-</span> <span class="mi">180</span><span class="p">)</span>
            <span class="n">dirAngle</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">angle</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">225</span> <span class="o">+</span> <span class="n">limit</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="ow">and</span> <span class="n">angle</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="mi">315</span> <span class="o">-</span> <span class="n">limit</span><span class="p">[</span><span class="mi">3</span><span class="p">]):</span>
            <span class="n">orgAngle</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
            <span class="n">corAngle</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">angle</span> <span class="o">-</span> <span class="mi">270</span><span class="p">)</span>
            <span class="n">dirAngle</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">angle</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">315</span> <span class="o">+</span> <span class="n">limit</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="n">angle</span> <span class="o">&lt;=</span> <span class="mi">360</span><span class="p">:</span>
            <span class="n">orgAngle</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
            <span class="n">corAngle</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">angle</span> <span class="o">-</span> <span class="mi">360</span><span class="p">)</span>
            <span class="n">dirAngle</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">angle</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">angle</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="mi">45</span> <span class="o">-</span> <span class="n">limit</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">orgAngle</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
            <span class="n">corAngle</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
            <span class="n">dirAngle</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">limit</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span>
        <span class="n">limit</span><span class="p">[</span><span class="n">dirAngle</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">maxAngleChange</span>  <span class="c1"># Set angle limit for the current direction</span>
        <span class="n">limit</span><span class="p">[</span>
            <span class="p">(</span><span class="n">dirAngle</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span>
        <span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">maxAngleChange</span>  <span class="c1"># Extend the angles for the adjacent directions</span>
        <span class="n">limit</span><span class="p">[(</span><span class="n">dirAngle</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">maxAngleChange</span>

    <span class="k">return</span> <span class="n">orgAngle</span><span class="p">,</span> <span class="n">corAngle</span><span class="p">,</span> <span class="n">dirAngle</span></div>



<div class="viewcode-block" id="rotate_polygon">
<a class="viewcode-back" href="../../../aerial_conversion.orthogonalise.html#aerial_conversion.orthogonalise.orthogonalise.rotate_polygon">[docs]</a>
<span class="k">def</span> <span class="nf">rotate_polygon</span><span class="p">(</span><span class="n">polySimple</span><span class="p">,</span> <span class="n">angle</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Rotates polygon around its centroid for given angle.</span>

<span class="sd">    :Parameters:</span>
<span class="sd">      - `polySimple: shapely polygon object containing simplified building.</span>
<span class="sd">      - `angle: angle of rotation in decimal degrees.</span>
<span class="sd">                Positive = counter-clockwise, Negative = clockwise</span>

<span class="sd">    :Returns:</span>
<span class="sd">      - bSR: rotated polygon</span>

<span class="sd">    :Returns Type:</span>
<span class="sd">      shapely Polygon</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create WGS84 referenced GeoSeries</span>
    <span class="n">bS</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">({</span><span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">polySimple</span><span class="p">]})</span>
    <span class="n">bS</span><span class="o">.</span><span class="n">crs</span> <span class="o">=</span> <span class="s2">&quot;EPSG:4326&quot;</span>

    <span class="c1"># Temporary reproject to Merkator and rotate by median angle</span>
    <span class="n">bSR</span> <span class="o">=</span> <span class="n">bS</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="s2">&quot;epsg:3857&quot;</span><span class="p">)</span>
    <span class="n">bSR</span> <span class="o">=</span> <span class="n">bSR</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s2">&quot;centroid&quot;</span><span class="p">,</span> <span class="n">use_radians</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">bSR</span> <span class="o">=</span> <span class="n">bSR</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="s2">&quot;epsg:4326&quot;</span><span class="p">)</span>

    <span class="c1"># Extract only shapely polygon object</span>
    <span class="n">bSR</span> <span class="o">=</span> <span class="n">bSR</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">bSR</span></div>



<div class="viewcode-block" id="orthogonalise_polygon">
<a class="viewcode-back" href="../../../aerial_conversion.orthogonalise.html#aerial_conversion.orthogonalise.orthogonalise.orthogonalise_polygon">[docs]</a>
<span class="k">def</span> <span class="nf">orthogonalise_polygon</span><span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="n">maxAngleChange</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">skewTolerance</span><span class="o">=</span><span class="mi">15</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Master function that makes all angles in polygon outer and inner rings</span>
<span class="sd">    either 90 or 180 degrees. Idea adapted from JOSM function orthogonalize 1)</span>
<span class="sd">    Calculate bearing [0-360 deg] of each polygon segment 2) From bearing</span>
<span class="sd">    determine general direction [N, E, S ,W], then calculate angle deviation</span>
<span class="sd">    from nearest cardinal direction for each segment 3) Rotate polygon by</span>
<span class="sd">    median deviation angle to align segments with xy coord axes (cardinal</span>
<span class="sd">    directions) 4) For vertical segments replace X coordinates of their points</span>
<span class="sd">    with mean value For horizontal segments replace Y coordinates of their</span>
<span class="sd">    points with mean value 5) Rotate back.</span>

<span class="sd">    :Parameters:</span>
<span class="sd">      - `polygon: shapely polygon object containing simplified building.</span>
<span class="sd">      - `maxAngleChange: angle (0,45&gt; degrees. Sets the maximum angle deviation</span>
<span class="sd">                         from the cardinal direction for the segment to be still</span>
<span class="sd">                         considered to continue in the same direction as the</span>
<span class="sd">                         previous segment.</span>
<span class="sd">      - `skewTolerance: angle &lt;0,45&gt; degrees. Sets skew tolerance for segments that</span>
<span class="sd">                        are at 45˚±Tolerance angle from the overal rectangular shape</span>
<span class="sd">                        of the polygon. Usefull when preserving e.g. bay windows on a</span>
<span class="sd">                        house.</span>

<span class="sd">    :Returns:</span>
<span class="sd">      - polyOrthog: orthogonalized shapely polygon where all angles are 90 or 180 degrees</span>

<span class="sd">    :Returns Type:</span>
<span class="sd">      shapely Polygon</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check if polygon has inner rings that we want to orthogonalize as well</span>
    <span class="n">rings</span> <span class="o">=</span> <span class="p">[</span><span class="n">Polygon</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">exterior</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">inner</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">interiors</span><span class="p">):</span>
        <span class="n">rings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Polygon</span><span class="p">(</span><span class="n">inner</span><span class="p">))</span>

    <span class="n">polyOrthog</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">polySimple</span> <span class="ow">in</span> <span class="n">rings</span><span class="p">:</span>
        <span class="c1"># print(polySimple)</span>
        <span class="c1"># print(&quot;Validity: &quot;,polySimple.is_valid)</span>

        <span class="k">if</span> <span class="n">polySimple</span><span class="o">.</span><span class="n">is_valid</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Polygon is not valid. Trying to fix it.&quot;</span><span class="p">)</span>
            <span class="n">polySimple</span> <span class="o">=</span> <span class="n">polySimple</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">polySimple</span><span class="o">.</span><span class="n">is_valid</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Polygon is not valid. Trying to fix it again.&quot;</span><span class="p">)</span>
            <span class="n">polySimple</span> <span class="o">=</span> <span class="n">polySimple</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="mf">0.0000001</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">polySimple</span><span class="o">.</span><span class="n">is_valid</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Polygon is not valid. The reason is explained below:&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">explain_validity</span><span class="p">(</span><span class="n">polySimple</span><span class="p">))</span>

        <span class="n">polySimple</span> <span class="o">=</span> <span class="n">make_valid</span><span class="p">(</span><span class="n">polySimple</span><span class="p">)</span>

        <span class="c1"># Get angles from cardinal directions of all segments</span>
        <span class="n">orgAngle</span><span class="p">,</span> <span class="n">corAngle</span><span class="p">,</span> <span class="n">dirAngle</span> <span class="o">=</span> <span class="n">calculate_segment_angles</span><span class="p">(</span><span class="n">polySimple</span><span class="p">)</span>

        <span class="c1"># Calculate median angle that will be used for rotation</span>
        <span class="k">if</span> <span class="n">statistics</span><span class="o">.</span><span class="n">stdev</span><span class="p">(</span><span class="n">corAngle</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">30</span><span class="p">:</span>
            <span class="n">medAngle</span> <span class="o">=</span> <span class="n">statistics</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">corAngle</span><span class="p">)</span>
            <span class="c1"># avAngle = statistics.mean(corAngle)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">medAngle</span> <span class="o">=</span> <span class="mi">45</span>  <span class="c1"># Account for cases when building is at ~45˚ and we can&#39;t decide if to turn clockwise or anti-clockwise</span>

        <span class="c1"># Rotate polygon to align its edges to cardinal directions</span>
        <span class="n">polySimpleR</span> <span class="o">=</span> <span class="n">rotate_polygon</span><span class="p">(</span><span class="n">polySimple</span><span class="p">,</span> <span class="n">medAngle</span><span class="p">)</span>

        <span class="c1"># Get directions of rotated polygon segments</span>
        <span class="n">orgAngle</span><span class="p">,</span> <span class="n">corAngle</span><span class="p">,</span> <span class="n">dirAngle</span> <span class="o">=</span> <span class="n">calculate_segment_angles</span><span class="p">(</span>
            <span class="n">polySimpleR</span><span class="p">,</span> <span class="n">maxAngleChange</span>
        <span class="p">)</span>

        <span class="c1"># Get Lat/Lon of rotated polygon points</span>
        <span class="n">rotatedX</span> <span class="o">=</span> <span class="n">polySimpleR</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">rotatedY</span> <span class="o">=</span> <span class="n">polySimpleR</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="c1"># Scan backwards to check if starting segment is a continuation of straight region in the same direction</span>
        <span class="n">shift</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dirAngle</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">dirAngle</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">dirAngle</span><span class="p">[</span><span class="o">-</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">shift</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="c1"># If the first segment is part of continuing straight region then reset the index to its beginning</span>
        <span class="k">if</span> <span class="n">shift</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dirAngle</span> <span class="o">=</span> <span class="n">dirAngle</span><span class="p">[</span><span class="o">-</span><span class="n">shift</span><span class="p">:]</span> <span class="o">+</span> <span class="n">dirAngle</span><span class="p">[:</span><span class="o">-</span><span class="n">shift</span><span class="p">]</span>
            <span class="n">orgAngle</span> <span class="o">=</span> <span class="n">orgAngle</span><span class="p">[</span><span class="o">-</span><span class="n">shift</span><span class="p">:]</span> <span class="o">+</span> <span class="n">orgAngle</span><span class="p">[:</span><span class="o">-</span><span class="n">shift</span><span class="p">]</span>
            <span class="n">rotatedX</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">rotatedX</span><span class="p">[</span><span class="o">-</span><span class="n">shift</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">rotatedX</span><span class="p">[:</span><span class="o">-</span><span class="n">shift</span><span class="p">]</span>
            <span class="p">)</span>  <span class="c1"># First and last points are the same in closed polygons</span>
            <span class="n">rotatedY</span> <span class="o">=</span> <span class="n">rotatedY</span><span class="p">[</span><span class="o">-</span><span class="n">shift</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">rotatedY</span><span class="p">[:</span><span class="o">-</span><span class="n">shift</span><span class="p">]</span>

        <span class="c1"># Fix 180 degree turns (N-&gt;S, S-&gt;N, E-&gt;W, W-&gt;E)</span>
        <span class="c1"># Subtract two adjacent directions and if the difference is 2, which means we have 180˚ turn (0,1,3 are OK) then use the direction of the previous segment</span>
        <span class="n">dirAngleRoll</span> <span class="o">=</span> <span class="n">dirAngle</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">dirAngle</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">dirAngle</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">dirAngle</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dirAngle</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">dirAngleRoll</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">else</span> <span class="n">dirAngle</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dirAngle</span><span class="p">))</span>
        <span class="p">]</span>

        <span class="c1"># Cycle through all segments</span>
        <span class="c1"># Adjust points coodinates by taking the average of points in segment</span>
        <span class="n">dirAngle</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dirAngle</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># Append dummy value</span>
        <span class="n">orgAngle</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">orgAngle</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># Append dummy value</span>
        <span class="n">segmentBuffer</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">[]</span>
        <span class="p">)</span>  <span class="c1"># Buffer for determining which segments are part of one large straight line</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dirAngle</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># Preserving skewed walls: Leave walls that are obviously meant to be skewed 45˚+/- tolerance˚ (e.g.angle 30-60 degrees) off main walls as untouched</span>
            <span class="k">if</span> <span class="n">orgAngle</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="mi">90</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">45</span> <span class="o">-</span> <span class="n">skewTolerance</span><span class="p">)</span> <span class="ow">and</span> <span class="n">orgAngle</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="mi">90</span> <span class="o">&lt;</span> <span class="p">(</span>
                <span class="mi">45</span> <span class="o">+</span> <span class="n">skewTolerance</span>
            <span class="p">):</span>
                <span class="k">continue</span>

            <span class="c1"># Dealing with adjacent segments following the same direction</span>
            <span class="n">segmentBuffer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">dirAngle</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">dirAngle</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="p">):</span>  <span class="c1"># If next segment is of same orientation, we need 180 deg angle for straight line. Keep checking.</span>
                <span class="k">if</span> <span class="n">orgAngle</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">%</span> <span class="mi">90</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">45</span> <span class="o">-</span> <span class="n">skewTolerance</span><span class="p">)</span> <span class="ow">and</span> <span class="n">orgAngle</span><span class="p">[</span>
                    <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="p">]</span> <span class="o">%</span> <span class="mi">90</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">45</span> <span class="o">+</span> <span class="n">skewTolerance</span><span class="p">):</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">continue</span>

            <span class="k">if</span> <span class="n">dirAngle</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">}:</span>  <span class="c1"># for N,S segments avereage x coordinate</span>
                <span class="n">tempX</span> <span class="o">=</span> <span class="n">statistics</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span>
                    <span class="n">rotatedX</span><span class="p">[</span><span class="n">segmentBuffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span> <span class="n">segmentBuffer</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="c1"># Update with new coordinates</span>
                <span class="n">rotatedX</span><span class="p">[</span><span class="n">segmentBuffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span> <span class="n">segmentBuffer</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">tempX</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">segmentBuffer</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="p">)</span>  <span class="c1"># Segment has 2 points therefore +1</span>
            <span class="k">elif</span> <span class="n">dirAngle</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">}:</span>  <span class="c1"># for E,W segments avereage y coordinate</span>
                <span class="n">tempY</span> <span class="o">=</span> <span class="n">statistics</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span>
                    <span class="n">rotatedY</span><span class="p">[</span><span class="n">segmentBuffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span> <span class="n">segmentBuffer</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="c1"># Update with new coordinates</span>
                <span class="n">rotatedY</span><span class="p">[</span><span class="n">segmentBuffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span> <span class="n">segmentBuffer</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">tempY</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">segmentBuffer</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span>
                <span class="mi">0</span> <span class="ow">in</span> <span class="n">segmentBuffer</span>
            <span class="p">):</span>  <span class="c1"># Copy change in first point to its last point so we don&#39;t lose it during Reverse shift</span>
                <span class="n">rotatedX</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">rotatedX</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">rotatedY</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">rotatedY</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">segmentBuffer</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Reverse shift so we get polygon with the same start/end point as before</span>
        <span class="k">if</span> <span class="n">shift</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">rotatedX</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">rotatedX</span><span class="p">[</span><span class="n">shift</span><span class="p">:]</span> <span class="o">+</span> <span class="n">rotatedX</span><span class="p">[</span><span class="mi">1</span> <span class="p">:</span> <span class="n">shift</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="p">)</span>  <span class="c1"># First and last points are the same in closed polygons</span>
            <span class="n">rotatedY</span> <span class="o">=</span> <span class="n">rotatedY</span><span class="p">[</span><span class="n">shift</span><span class="p">:]</span> <span class="o">+</span> <span class="n">rotatedY</span><span class="p">[</span><span class="mi">1</span> <span class="p">:</span> <span class="n">shift</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rotatedX</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">rotatedX</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Copy updated coordinates to first node</span>
            <span class="n">rotatedY</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">rotatedY</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Create polygon from new points</span>
        <span class="n">polyNew</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">rotatedX</span><span class="p">,</span> <span class="n">rotatedY</span><span class="p">))</span>

        <span class="c1"># Rotate polygon back</span>
        <span class="n">polyNew</span> <span class="o">=</span> <span class="n">rotate_polygon</span><span class="p">(</span><span class="n">polyNew</span><span class="p">,</span> <span class="o">-</span><span class="n">medAngle</span><span class="p">)</span>

        <span class="c1"># Add to list of finihed rings</span>
        <span class="n">polyOrthog</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">polyNew</span><span class="p">)</span>

    <span class="c1"># Recreate the original object</span>
    <span class="n">polyOrthog</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span>
        <span class="n">polyOrthog</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">exterior</span><span class="p">,</span> <span class="p">[</span><span class="n">inner</span><span class="o">.</span><span class="n">exterior</span> <span class="k">for</span> <span class="n">inner</span> <span class="ow">in</span> <span class="n">polyOrthog</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">polyOrthog</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Sydney Informatics Hub (SIH).</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>